import {
    Extension,
    InjectionManager,
    gettext as _
} from 'resource:///org/gnome/shell/extensions/extension.js';

import { panel } from 'resource:///org/gnome/shell/ui/main.js';
import { Indicator } from 'resource:///org/gnome/shell/ui/status/system.js';
import Gio from 'gi://Gio';
import UPower from 'gi://UPowerGlib';
import GObject from 'gi://GObject';
import St from 'gi://St';
import GLib from 'gi://GLib';
import Rsvg from 'gi://Rsvg';
import Cairo from 'cairo';

const BAT0 = '/sys/class/power_supply/BAT0/';
const BAT1 = '/sys/class/power_supply/BAT1/';
const BAT2 = '/sys/class/power_supply/BAT2/';

let batteryCorrection = null;
let lastOverrideTime = 0;
let overrideCallCount = 0;
const MAX_CALLS_PER_SECOND = 100;
// Force DEBUG on for investigation
let DEBUG = false;

// Callback to trigger UI update when async read finishes
let updateUI = null;

// Professional logging utility
const LogLevel = {
    VERBOSE: 0,
    DEBUG: 1,
    INFO: 2,
    WARN: 3,
    ERROR: 4,
};

const LOG_LEVEL_NAMES = {
    [LogLevel.VERBOSE]: '[VERBOSE]',
    [LogLevel.DEBUG]: '[DEBUG]',
    [LogLevel.INFO]: '[INFO]',
    [LogLevel.WARN]: '[WARN]',
    [LogLevel.ERROR]: '[ERROR]',
};

let currentLogLevel = LogLevel.WARN;
let currentLogFilePath = null;
let logFileInitialized = false;
let logToFileEnabled = false;

// Circular indicator state
let circleIndicator = null;
let circleIndicatorParent = null;
let circleIndicatorStockIcon = null;
let circleIndicatorWasVisible = null;
let batteryIndicator = null;
let batteryIndicatorParent = null;
let batteryIndicatorStockIcon = null;
let batteryIndicatorWasVisible = null;
let shouldShowIndicator = true;

const CIRCLE_PANEL_SIZE_RATIO = 0.75;
const CIRCLE_MIN_SIZE = 12;
const CIRCLE_RING_OUTER_PADDING = 2;
const CIRCLE_RING_INNER_RATIO = 0.9;
const CIRCLE_ARC_START_ANGLE = -Math.PI / 2;
const CIRCLE_DEGREES_PER_PERCENT = 3.6;
const CIRCLE_FONT_SIZE_RATIO = 0.33;
const CIRCLE_CHARGING_ICON_SCALE = 1.7;
const CIRCLE_CHARGING_ICON_SPACING = 1.05;
const CIRCLE_LOW_BATTERY_THRESHOLD = 50;
const CIRCLE_SIZE_SCALE = 1.48;
const BATTERY_MIN_SIZE = 12;
const BATTERY_OUTER_PADDING = 2;

function getRingColor(percentage) {
    let red = 0;
    let green = 0;
    const blue = 0;

    if (percentage <= CIRCLE_LOW_BATTERY_THRESHOLD) {
        red = 1;
        green = Math.max(0, percentage / CIRCLE_LOW_BATTERY_THRESHOLD);
    } else {
        green = 1;
        red = 1 - (percentage - CIRCLE_LOW_BATTERY_THRESHOLD) / CIRCLE_LOW_BATTERY_THRESHOLD;
    }

    return [red, green, blue];
}

function getLabelStyleFromPercentage(percentage, useColor) {
    if (!useColor || percentage === null || percentage === undefined || Number.isNaN(percentage)) {
        return '';
    }

    const [red, green, blue] = getRingColor(Math.round(percentage));
    const r = Math.round(red * 255);
    const g = Math.round(green * 255);
    const b = Math.round(blue * 255);
    return `color: rgb(${r}, ${g}, ${b});`;
}

function getForegroundColor(component) {
    try {
        const themeNode = component.get_theme_node();
        return themeNode.get_foreground_color();
    } catch (error) {
        return { red: 255, green: 255, blue: 255 };
    }
}

function isChargingState(proxy, status) {
    const state = proxy?.State;
    return state === UPower.DeviceState.CHARGING
        || state === UPower.DeviceState.PENDING_CHARGE
        || (status && status.includes('Charging'));
}

function getCircleSize(settings) {
    const configured = settings?.get_int('circlesize') ?? 0;
    const raw = Math.max(CIRCLE_MIN_SIZE_USER, configured || CIRCLE_MIN_SIZE_USER);
    return Math.round(raw * CIRCLE_SIZE_SCALE);
}

function getBatteryWidth(settings) {
    const configured = settings?.get_int('batterysize') ?? 0;
    return Math.max(BATTERY_MIN_SIZE, configured || BATTERY_MIN_SIZE);
}

function getBatteryHeight(settings) {
    const configured = settings?.get_int('batteryheight') ?? 0;
    return Math.max(BATTERY_MIN_SIZE, configured || BATTERY_MIN_SIZE);
}

function resetPowerToggleStyles() {
    const system = panel.statusArea.quickSettings?._system;
    const powerToggle = system?._systemItem?.powerToggle;
    if (!powerToggle) {
        return;
    }

    powerToggle.set_style?.('');
    powerToggle._title?.set_style?.('');
    powerToggle._titleLabel?.set_style?.('');
    powerToggle._percentageLabel?.set_style?.('');
    powerToggle._icon?.set_style?.('');
    powerToggle._titleLabel?.set_text?.('');
    powerToggle._percentageLabel?.set_text?.('');
    if (typeof powerToggle.title !== 'undefined') {
        powerToggle.title = '';
    }
    if (powerToggle._icon) {
        powerToggle._icon.visible = true;
    }

    const indicator = system?._indicator;
    indicator?._percentageLabel?.set_style?.('');
    indicator?._percentageLabel?.set_text?.('');
    indicator?._icon?.set_style?.('');
    indicator?._percentageLabel?.set_text?.('');
    indicator?._percentageLabel?.set_style?.('');
}

function logDebug(msg) {
    logMessage(msg, LogLevel.DEBUG);
}

function logInfo(msg) {
    logMessage(msg, LogLevel.INFO);
}

function logWarn(msg) {
    logMessage(msg, LogLevel.WARN);
}

function logError(msg) {
    logMessage(msg, LogLevel.ERROR);
}

function updateGlobalsFromSettings(settings) {
    DEBUG = settings.get_boolean('debug');
    currentLogLevel = settings.get_int('loglevel');
    logToFileEnabled = settings.get_boolean('logtofile');
    currentLogFilePath = settings.get_string('logfilepath');

    // Reset file init flag if path changed (simple approach) or just let it handle it
    if (logFileInitialized && currentLogFilePath !== settings.get_string('logfilepath')) {
        logFileInitialized = false;
    }
}

function logMessage(msg, level = LogLevel.DEBUG) {
    if (!DEBUG) {
        return;
    }
    if (level < currentLogLevel) {
        return;
    }

    const timestamp = new Date().toISOString();
    const prefix = `${timestamp} ${LOG_LEVEL_NAMES[level]} [BatConsumptionWattmeter]`;
    const output = `${prefix} ${msg}`;

    if (level >= LogLevel.WARN) {
        console.error(output);
    } else {
        console.log(output);
    }

    if (logToFileEnabled && currentLogFilePath) {
        appendLogLine(currentLogFilePath, output);
    }
}

function resolveLogFilePath(settings) {
    const configured = settings.get_string('logfilepath').trim();
    if (configured.length === 0) {
        return `${GLib.get_user_cache_dir()}/batt-watt-power-monitor.log`;
    }
    if (configured.startsWith('/')) {
        return configured;
    }
    return `${GLib.get_home_dir()}/${configured}`;
}

function ensureLogDirectory(path) {
    const file = Gio.File.new_for_path(path);
    const parent = file.get_parent();
    if (parent && !parent.query_exists(null)) {
        try {
            parent.make_directory_with_parents(null);
        } catch (error) {
            console.error(`[BatConsumptionWattmeter] Failed to create log dir: ${error.message}`);
        }
    }
}

function rotateLogFile(path) {
    const file = Gio.File.new_for_path(path);
    if (!file.query_exists(null)) {
        return;
    }

    const oldFile = Gio.File.new_for_path(`${path}.old`);
    if (oldFile.query_exists(null)) {
        try {
            oldFile.delete(null);
        } catch (error) {
            console.error(`[BatConsumptionWattmeter] Failed to delete old log: ${error.message}`);
        }
    }

    try {
        file.move(oldFile, Gio.FileCopyFlags.OVERWRITE, null, null);
    } catch (error) {
        console.error(`[BatConsumptionWattmeter] Failed to rotate log: ${error.message}`);
    }
}

function initLogFile(path) {
    if (logFileInitialized && path === currentLogFilePath) {
        return;
    }
    ensureLogDirectory(path);
    rotateLogFile(path);
    logFileInitialized = true;
}

function appendLogLine(path, line) {
    try {
        ensureLogDirectory(path);
        const file = Gio.File.new_for_path(path);
        const output = `${line}\n`;
        const stream = file.append_to(Gio.FileCreateFlags.NONE, null);
        stream.write_all(output, null);
        stream.close(null);
    } catch (error) {
        console.error(`[BatConsumptionWattmeter] Failed to write log: ${error.message}`);
    }
}

// Shared SVG loading functions for both indicators
function loadChargingSvg(extensionPath, red, green, blue) {
    try {
        const svgPath = `${extensionPath}/bolt.svg`;
        logDebug(`Loading bolt SVG from: ${svgPath}, color RGB(${red}, ${green}, ${blue})`);
        const handle = Rsvg.Handle.new_from_file(svgPath);
        if (!handle) {
            logDebug('Failed to create SVG handle');
            return null;
        }

        const dimensions = handle.get_dimensions();
        const svgWidth = dimensions.width;
        const svgHeight = dimensions.height;

        const surface = new Cairo.ImageSurface(Cairo.Format.ARGB32, svgWidth, svgHeight);
        const context = new Cairo.Context(surface);
        handle.render_cairo(context);

        const tintSurface = new Cairo.ImageSurface(Cairo.Format.ARGB32, svgWidth, svgHeight);
        const tintContext = new Cairo.Context(tintSurface);
        tintContext.setSourceSurface(surface, 0, 0);
        tintContext.paint();
        tintContext.setOperator(Cairo.Operator.IN);
        tintContext.setSourceRGB(red, green, blue);
        tintContext.paint();

        return tintSurface;
    } catch (error) {
        logDebug(`Failed to load charging icon: ${error.message}`);
        return null;
    }
}

function loadChargingStrokeSvg(extensionPath) {
    try {
        const svgPath = `${extensionPath}/bolt_stroke.svg`;
        const handle = Rsvg.Handle.new_from_file(svgPath);
        if (!handle) {
            return null;
        }

        const dimensions = handle.get_dimensions();
        const svgWidth = dimensions.width;
        const svgHeight = dimensions.height;

        const surface = new Cairo.ImageSurface(Cairo.Format.ARGB32, svgWidth, svgHeight);
        const context = new Cairo.Context(surface);
        context.setSourceRGBA(0, 0, 0, 0);
        context.setOperator(Cairo.Operator.CLEAR);
        context.paint();
        context.setOperator(Cairo.Operator.OVER);
        handle.render_cairo(context);

        return surface;
    } catch (error) {
        logDebug(`Failed to load charging stroke icon: ${error.message}`);
        return null;
    }
}

// Shared function to draw battery icon
function drawBatteryIcon(context, centerX, centerY, width, height, percentage, red, green, blue, bodyWidthRatio = 0.42, bodyHeightRatio = 0.5, showText = false) {
    const bodyWidth = width * bodyWidthRatio;
    const bodyHeight = height * bodyHeightRatio;
    const bodyX = centerX - bodyWidth / 2;
    const bodyY = centerY - bodyHeight / 2;
    const nubWidth = bodyWidth * 0.28;
    const nubHeight = bodyHeight * 0.18;
    const nubX = centerX - nubWidth / 2;
    const nubY = bodyY - nubHeight * 0.9;

    context.save();
    context.setSourceRGB(red, green, blue);
    context.setLineWidth(1.2);
    context.rectangle(bodyX, bodyY, bodyWidth, bodyHeight);
    context.stroke();
    context.rectangle(nubX, nubY, nubWidth, nubHeight);
    context.stroke();

    const pct = Math.max(0, Math.min(100, Math.round(percentage)));
    const fillHeight = bodyHeight * (pct / 100);
    const fillY = bodyY + (bodyHeight - fillHeight);
    context.rectangle(bodyX + 1.5, fillY + 1.5, bodyWidth - 3, Math.max(0, fillHeight - 3));
    context.fill();

    if (showText) {
        logDebug(`drawBatteryIcon: rendering text, pct=${pct}, centerX=${centerX}, centerY=${centerY}`);
        context.selectFontFace('Sans', Cairo.FontSlant.NORMAL, Cairo.FontWeight.BOLD);
        context.setFontSize(Math.round(height * 0.28));
        const text = String(pct);
        const textExtents = context.textExtents(text);
        const textX = centerX - textExtents.width / 2;
        const textY = centerY + textExtents.height / 2;
        logDebug(`drawBatteryIcon: text="${text}", textX=${textX}, textY=${textY}, fontSize=${Math.round(height * 0.28)}`);
        context.setSourceRGB(red, green, blue);
        context.moveTo(textX, textY);
        context.showText(text);
        context.stroke();
    }

    context.restore();
}

// Shared function to draw SVG bolt icon
function drawBoltIcon(context, extensionPath, centerX, centerY, boltHeight, red, green, blue) {
    const svgSurface = loadChargingSvg(extensionPath, red, green, blue);
    if (!svgSurface) {
        return;
    }

    const svgHeight = svgSurface.getHeight();
    const svgWidth = svgSurface.getWidth();
    const scale = boltHeight / svgHeight;
    const scaledWidth = svgWidth * scale;
    const boltX = centerX - scaledWidth / 2;
    const boltY = centerY - boltHeight / 2;

    context.save();
    context.scale(scale, scale);
    context.setSourceSurface(svgSurface, boltX / scale, boltY / scale);
    context.paint();
    context.restore();

    const strokeSurface = loadChargingStrokeSvg(extensionPath);
    if (strokeSurface) {
        context.save();
        context.scale(scale, scale);
        context.setSourceSurface(strokeSurface, boltX / scale, boltY / scale);
        context.paint();
        context.restore();
    }
}

// Based on batteryIcon by slim8916 (MIT). Adapted and integrated here.
const CircleIndicator = GObject.registerClass(
    class CircleIndicator extends St.DrawingArea {
        _init(status, extensionPath) {
            const size = status?.size ?? CIRCLE_MIN_SIZE;
            super._init({ width: size, height: size });

            this._status = status;
            this._extensionPath = extensionPath;
            this._color = this._calculateColor();
            this._repaintId = this.connect('repaint', this._onRepaint.bind(this));
            this.visible = true;
        }

        _calculateColor() {
            if (!this._status.useColor) {
                const fg = getForegroundColor(this);
                return [fg.red / 255, fg.green / 255, fg.blue / 255];
            }
            return getRingColor(this._status.percentage);
        }



        _drawChargingIcon(context, centerX, centerY, textExtents, red, green, blue) {
            logDebug(`_drawChargingIcon called with RGB(${red}, ${green}, ${blue})`);
            const svgSurface = loadChargingSvg(this._extensionPath, red, green, blue);
            if (!svgSurface) {
                logDebug('SVG surface is null, returning');
                return centerX - textExtents.width / 2;
            }

            const svgHeight = svgSurface.getHeight();
            const svgWidth = svgSurface.getWidth();
            const scale = (textExtents.height * CIRCLE_CHARGING_ICON_SCALE) / svgHeight;
            const scaledWidth = svgWidth * scale;
            const scaledHeight = svgHeight * scale;

            const iconX = centerX - CIRCLE_CHARGING_ICON_SPACING * (textExtents.width + scaledWidth) / 2;
            const iconY = centerY - scaledHeight / 2;
            const textX = iconX + scaledWidth - 5;

            context.save();
            context.scale(scale, scale);
            context.setSourceSurface(svgSurface, iconX / scale, iconY / scale);
            context.paint();
            context.restore();

            const strokeSurface = loadChargingStrokeSvg(this._extensionPath);
            if (strokeSurface) {
                context.save();
                context.scale(scale, scale);
                context.setSourceSurface(strokeSurface, iconX / scale, iconY / scale);
                context.paint();
                context.restore();
            }

            return textX;
        }

        _drawBatteryIcon(context, centerX, centerY, width, height, red, green, blue) {
            drawBatteryIcon(context, centerX, centerY, width, height,
                this._status.percentage, red, green, blue);

            if (this._status.isCharging || this._status.forceBolt) {
                const boltHeight = height * 0.85;
                drawBoltIcon(context, this._extensionPath, centerX, centerY, boltHeight, red, green, blue);
            }
        }

        _onRepaint(area) {
            const context = area.get_context();
            const [width, height] = area.get_surface_size();

            context.setSourceRGBA(0, 0, 0, 0);
            context.setOperator(Cairo.Operator.CLEAR);
            context.paint();
            context.setOperator(Cairo.Operator.OVER);

            const [red, green, blue] = this._color;
            context.setSourceRGB(red, green, blue);

            const centerX = width / 2;
            const centerY = height / 2;
            const outerRadius = Math.min(width, height) / 2 - CIRCLE_RING_OUTER_PADDING;
            const innerRadius = outerRadius * CIRCLE_RING_INNER_RATIO;

            const arcEndAngle = (270 - (100 - this._status.percentage) * CIRCLE_DEGREES_PER_PERCENT) * Math.PI / 180;

            context.arc(centerX, centerY, outerRadius, CIRCLE_ARC_START_ANGLE, arcEndAngle);
            context.arcNegative(centerX, centerY, innerRadius, arcEndAngle, CIRCLE_ARC_START_ANGLE);
            context.closePath();
            context.fill();

            if (this._status.showText) {
                context.selectFontFace('Sans', Cairo.FontSlant.NORMAL, Cairo.FontWeight.BOLD);
                context.setFontSize(Math.round(height * CIRCLE_FONT_SIZE_RATIO));

                const text = String(this._status.percentage);
                const textExtents = context.textExtents(text);
                let textX = centerX - textExtents.width / 2;
                const textY = centerY + textExtents.height / 2;

                if (this._status.isCharging || this._status.forceBolt) {
                    textX = this._drawChargingIcon(context, centerX, centerY, textExtents, red, green, blue);
                }

                context.setSourceRGB(red, green, blue);
                context.moveTo(textX, textY);
                context.showText(text);
                context.stroke();
            } else {
                const iconWidth = innerRadius * 1.95;
                const iconHeight = innerRadius * 2.2;
                this._drawBatteryIcon(context, centerX, centerY, iconWidth, iconHeight, red, green, blue);
            }
        }

        update(status) {
            logDebug(`BatteryIndicator.update: width=${status.width}, batW=${status.batteryWidth}`);
            this._status = status;
            this._color = this._calculateColor();
            this.queue_repaint();
        }

        destroy() {
            if (this._repaintId) {
                this.disconnect(this._repaintId);
                this._repaintId = 0;
            }
            super.destroy();
        }
    });

const BatteryIndicator = GObject.registerClass(
    class BatteryIndicator extends St.DrawingArea {
        _init(status) {
            const width = status?.width ?? BATTERY_MIN_SIZE;
            const height = status?.height ?? BATTERY_MIN_SIZE;
            super._init({ width, height });
            this.set_size(width, height);
            this.set_width(width);
            this.set_height(height);
            this.set_style(`width: ${width}px; height: ${height}px; min-width: ${width}px; min-height: ${height}px;`);
            this.queue_relayout();

            this._status = status;
            this._extensionPath = status.extensionPath;
            this._color = this._calculateColor();
            this._repaintId = this.connect('repaint', this._onRepaint.bind(this));
            this.visible = true;
        }

        vfunc_get_preferred_width(_forHeight) {
            const width = this._status?.width ?? BATTERY_MIN_SIZE;
            return [width, width];
        }

        vfunc_get_preferred_height(_forWidth) {
            const height = this._status?.height ?? BATTERY_MIN_SIZE;
            return [height, height];
        }

        _calculateColor() {
            if (!this._status.useColor) {
                const fg = getForegroundColor(this);
                return [fg.red / 255, fg.green / 255, fg.blue / 255];
            }
            return getRingColor(this._status.percentage);
        }

        _onRepaint(area) {
            const context = area.get_context();
            const [width, height] = area.get_surface_size();
            logDebug(`_onRepaint: surfW=${width}, statusBatW=${this._status.batteryWidth}`);
            const desiredWidth = this._status.width ?? width;
            const desiredHeight = this._status.height ?? height;
            const drawWidth = Math.min(width, desiredWidth);
            const drawHeight = Math.min(height, desiredHeight);
            const offsetX = (width - drawWidth) / 2;
            const offsetY = (height - drawHeight) / 2;

            context.setSourceRGBA(0, 0, 0, 0);
            context.setOperator(Cairo.Operator.CLEAR);
            context.paint();
            context.setOperator(Cairo.Operator.OVER);

            const [red, green, blue] = this._color;

            const centerX = width / 2;
            const centerY = height / 2;
            const iconWidth = drawWidth * 0.9;
            const iconHeight = drawHeight * 0.9;

            // Flexible Layout Logic
            // We want to fit [Bolt] [Gap] [Battery] into drawWidth

            const gap = -2; // Slightly overlap bolt for tight look
            let boltWidth = 0;
            let boltHeight = 0;
            let boltScale = 0;
            let svgSurface = null;
            let strokeSurface = null;

            // Pre-calculate Bolt dimensions if needed
            if (this._status.isCharging || this._status.forceBolt) {
                svgSurface = loadChargingSvg(this._extensionPath, red, green, blue);
                if (svgSurface) {
                    const svgHeight = svgSurface.getHeight();
                    const svgWidth = svgSurface.getWidth();
                    boltHeight = iconHeight * 0.75; // Use max available height for bolt
                    boltScale = boltHeight / svgHeight;
                    boltWidth = svgWidth * boltScale;
                    strokeSurface = loadChargingStrokeSvg(this._extensionPath);
                }
            }

            // Calculate Battey dimensions
            // Use explicit battery width from status (passed from update/init)
            let rawBatteryW = this._status.batteryWidth;

            if (rawBatteryW === undefined) {
                rawBatteryW = this._status?.width ?? width;
            }

            // Apply 0.9 scale factor consistent with iconHeight (padding)
            let batteryDrawWidth = rawBatteryW * 0.9;

            if (boltWidth > 0) {
                const availableForBattery = iconWidth - boltWidth - gap;
                if (batteryDrawWidth > availableForBattery) {
                    batteryDrawWidth = Math.max(BATTERY_MIN_SIZE, availableForBattery);
                }
            }

            // Determine Start X to center the group [Bolt-Gap-Battery]
            const totalGroupWidth = boltWidth > 0 ? (boltWidth + gap + batteryDrawWidth) : batteryDrawWidth;
            const startX = centerX - totalGroupWidth / 2;

            // Draw Bolt
            if (boltWidth > 0 && svgSurface) {
                const iconX = startX;
                const iconY = centerY - boltHeight / 2;

                context.save();
                context.scale(boltScale, boltScale);
                context.setSourceSurface(svgSurface, iconX / boltScale, iconY / boltScale);
                context.paint();
                context.restore();

                if (strokeSurface) {
                    context.save();
                    context.scale(boltScale, boltScale);
                    context.setSourceSurface(strokeSurface, iconX / boltScale, iconY / boltScale);
                    context.paint();
                    context.restore();
                }
            }

            // Draw Battery Body
            const batteryCenterX = startX + (boltWidth > 0 ? (boltWidth + gap) : 0) + batteryDrawWidth / 2;

            // Note: passing batteryDrawWidth as layout width
            drawBatteryIcon(context, batteryCenterX, centerY, batteryDrawWidth, iconHeight,
                this._status.percentage, red, green, blue, 0.7, 0.75, false);

            // Draw Text (Centered in Battery)
            if (this._status.showText) {
                context.selectFontFace('Sans', Cairo.FontSlant.NORMAL, Cairo.FontWeight.BOLD);
                context.setFontSize(Math.round(height * 0.28));

                const text = String(this._status.percentage);
                const textExtents = context.textExtents(text);
                const textX = batteryCenterX - textExtents.width / 2;
                const textY = centerY + textExtents.height / 2;

                // Draw text with black outline
                context.setSourceRGB(0, 0, 0);
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        if (dx !== 0 || dy !== 0) {
                            context.moveTo(textX + dx, textY + dy);
                            context.showText(text);
                        }
                    }
                }

                context.setSourceRGB(red, green, blue);
                context.moveTo(textX, textY);
                context.showText(text);
                context.fill();
            }
        }

        update(status) {
            this._status = status;
            this._color = this._calculateColor();
            this.queue_repaint();
        }

        destroy() {
            if (this._repaintId) {
                this.disconnect(this._repaintId);
                this._repaintId = 0;
            }
            super.destroy();
        }
    });

function circleIndicatorEnabled(settings) {
    return settings && settings.get_boolean('usecircleindicator');
}

function ensureCircleIndicator(settings, extensionPath) {
    if (!circleIndicatorEnabled(settings)) {
        destroyCircleIndicator();
        return;
    }

    if (circleIndicator) {
        const desiredSize = getCircleSize(settings);
        if (circleIndicator.width !== desiredSize || circleIndicator.height !== desiredSize) {
            destroyCircleIndicator();
        } else {
            return;
        }
    }

    destroyBatteryIndicator();
    const system = panel.statusArea.quickSettings?._system;
    circleIndicatorStockIcon = system?._indicator ?? null;
    circleIndicatorParent = circleIndicatorStockIcon?.get_parent() ?? null;
    circleIndicator = new CircleIndicator({
        percentage: 0,
        isCharging: false,
        showText: true,
        useColor: settings.get_boolean('showcolored'),
        forceBolt: settings.get_boolean('forcebolt'),
        size: getCircleSize(settings),
    }, extensionPath);

    if (circleIndicatorParent && circleIndicatorStockIcon) {
        circleIndicatorParent.insert_child_above(circleIndicator, circleIndicatorStockIcon);
        circleIndicatorWasVisible = circleIndicatorStockIcon.visible;
        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
            circleIndicatorStockIcon?.hide();
            return GLib.SOURCE_REMOVE;
        });
    } else if (panel?._rightBox) {
        panel._rightBox.insert_child_at_index(circleIndicator, 0);
    }
}

function destroyCircleIndicator() {
    if (!circleIndicator) {
        return;
    }

    circleIndicator.destroy();
    circleIndicator = null;

    if (circleIndicatorStockIcon) {
        if (circleIndicatorWasVisible === false) {
            circleIndicatorStockIcon.hide();
        } else {
            circleIndicatorStockIcon.show();
        }
    }

    circleIndicatorParent = null;
    circleIndicatorStockIcon = null;
    circleIndicatorWasVisible = null;
}

function updateCircleIndicatorStatus(proxy, settings) {
    if (!circleIndicatorEnabled(settings) || !circleIndicator || !proxy) {
        return;
    }

    const percentage = Math.round(proxy.Percentage);
    const status = getStatus(getAutopath());
    const isCharging = isChargingState(proxy, status) || settings.get_boolean('forcebolt');
    const showText = settings.get_boolean('percentage') && !settings.get_boolean('showpercentageoutside');
    const useColor = settings.get_boolean('showcolored');
    const forceBolt = settings.get_boolean('forcebolt');
    logDebug(`Circle status: state=${proxy.State} status=${status} charging=${isCharging} pct=${percentage}`);
    circleIndicator.update({ percentage, isCharging, showText, useColor, forceBolt });
}

function batteryIndicatorEnabled(settings) {
    return settings && settings.get_boolean('showicon') && !circleIndicatorEnabled(settings);
}

function ensureBatteryIndicator(settings, extensionPath) {
    if (!batteryIndicatorEnabled(settings)) {
        destroyBatteryIndicator();
        return;
    }

    if (batteryIndicator) {
        const desiredWidth = getBatteryWidth(settings);
        const desiredHeight = getBatteryHeight(settings);
        batteryIndicator.set_style(`width: ${desiredWidth}px; height: ${desiredHeight}px; min-width: ${desiredWidth}px; min-height: ${desiredHeight}px;`);
        batteryIndicator.queue_relayout();
        batteryIndicator.update({
            percentage: batteryIndicator._status?.percentage ?? 0,
            isCharging: batteryIndicator._status?.isCharging ?? false,
            showText: batteryIndicator._status?.showText ?? false,
            useColor: batteryIndicator._status?.useColor ?? false,
            extensionPath: batteryIndicator._extensionPath,
            width: desiredWidth,
            height: desiredHeight,
            batteryWidth: desiredWidth,
            settings: settings, // Pass settings for direct access
        });
        return;
    }

    const system = panel.statusArea.quickSettings?._system;
    batteryIndicatorStockIcon = system?._indicator ?? null;
    batteryIndicatorParent = batteryIndicatorStockIcon?.get_parent() ?? null;
    const batteryW = getBatteryWidth(settings);
    batteryIndicator = new BatteryIndicator({
        percentage: 0,
        isCharging: false,
        showText: false,
        useColor: settings.get_boolean('showcolored'),
        forceBolt: settings.get_boolean('forcebolt'),
        width: batteryW,
        batteryWidth: batteryW,
        settings: settings, // Pass settings for direct access
        extensionPath,
    });

    if (batteryIndicatorParent && batteryIndicatorStockIcon) {
        batteryIndicatorParent.insert_child_above(batteryIndicator, batteryIndicatorStockIcon);
        batteryIndicatorWasVisible = batteryIndicatorStockIcon.visible;
        GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {
            batteryIndicatorStockIcon?.hide();
            return GLib.SOURCE_REMOVE;
        });
    } else if (panel?._rightBox) {
        panel._rightBox.insert_child_at_index(batteryIndicator, 0);
    }
}

function destroyBatteryIndicator() {
    if (!batteryIndicator) {
        return;
    }

    batteryIndicator.destroy();
    batteryIndicator = null;

    if (batteryIndicatorStockIcon) {
        if (batteryIndicatorWasVisible === false) {
            batteryIndicatorStockIcon.hide();
        } else {
            batteryIndicatorStockIcon.show();
        }
    }

    batteryIndicatorParent = null;
    batteryIndicatorStockIcon = null;
    batteryIndicatorWasVisible = null;
}

function updateBatteryIndicatorStatus(proxy, settings) {
    if (!batteryIndicatorEnabled(settings) || !batteryIndicator || !proxy) {
        return;
    }

    const percentage = Math.round(proxy.Percentage);
    const showText = settings.get_boolean('percentage') && !settings.get_boolean('showpercentageoutside');
    const status = getStatus(getAutopath());
    const isCharging = isChargingState(proxy, status) || settings.get_boolean('forcebolt');
    const useColor = settings.get_boolean('showcolored');
    const forceBolt = settings.get_boolean('forcebolt');
    logDebug(`Bar status: state=${proxy.State} status=${status} charging=${isCharging} pct=${percentage}`);

    const batteryW = getBatteryWidth(settings);
    const height = getBatteryHeight(settings);
    // Expand widget width if charging to fit the bolt side-by-side
    const extraForBolt = isCharging ? Math.round(height * 0.6) : 0;
    const desiredWidth = batteryW + extraForBolt;

    batteryIndicator.set_style(`width: ${desiredWidth}px; height: ${height}px; min-width: ${desiredWidth}px; min-height: ${height}px;`);
    batteryIndicator.queue_relayout();
    batteryIndicator.update({
        percentage,
        useColor,
        showText,
        isCharging,
        forceBolt,
        width: desiredWidth,
        height,
        batteryWidth: batteryW, // Explicit width of battery body
    });
}

const fileCache = new Map();
const pendingReads = new Set();

/**
 * Reads file content asynchronously to comply with EGO review guidelines.
 * Note: This prevents freezing the Shell UI but may cause a slight delay 
 * in wattage updates as the UI refreshes only after the file read completes.
 */
function readFileSafely(filePath, defaultValue) {
    // Get current cached value (or default)
    const currentVal = fileCache.has(filePath) ? fileCache.get(filePath) : defaultValue;

    // Always try to refresh in background if not already reading
    if (!pendingReads.has(filePath)) {
        logDebug(`READING ASYNC: ${filePath}`);
        pendingReads.add(filePath);

        const file = Gio.File.new_for_path(filePath);
        file.load_contents_async(null, (source, res) => {
            try {
                const [ok, contents] = source.load_contents_finish(res);
                if (ok) {
                    const newValue = new TextDecoder('utf-8').decode(contents).trim();
                    logDebug(`READ SUCCESS for ${filePath}: ${newValue}`);

                    const oldValue = fileCache.get(filePath);
                    fileCache.set(filePath, newValue);

                    // If value changed (or first read), trigger UI update
                    if (newValue !== oldValue && updateUI) {
                        logDebug('Value changed, triggering UI update');
                        updateUI();
                    }
                }
            } catch (error) {
                logDebug(`READ ERROR for ${filePath}: ${error.message}`);
            } finally {
                pendingReads.delete(filePath);
            }
        });
    }

    return currentVal;
}

function getAutopath() {
    for (const path of [BAT0, BAT1, BAT2]) {
        if (readFileSafely(path + 'status', 'none') !== 'none') {
            const isTP = readFileSafely(path + 'power_now', 'none') !== 'none';
            return {
                path,
                isTP
            };
        }
    }
    return {
        'path': -1,
        'isTP': false
    };
}

function getValue(pathToFile) {
    const value = parseFloat(readFileSafely(pathToFile, -1));
    return value === -1 ? value : value / 1000000;
}

function getPower(correction) {
    if (!correction || !correction['path']) {
        correction = getAutopath();
        if (!correction || !correction['path']) {
            return 0;
        }
    }
    const path = correction['path'];
    let val;
    if (correction['isTP'] === false) {
        val = getValue(path + 'current_now') * getValue(path + 'voltage_now');
    } else {
        val = getValue(path + 'power_now');
    }

    {
        const energyNow = getValue(path + 'energy_now');
        console.log(`[BatConsumptionWattmeter] Raw Power: ${val} W | Energy Now: ${energyNow} Wh`);
    }

    return val;
}

function getStatus(correction) {
    if (!correction || !correction['path']) {
        correction = getAutopath();
        if (!correction || !correction['path']) {
            return 'Unknown';
        }
    }
    return readFileSafely(correction['path'] + 'status', 'Unknown');
}

function formatWatts(power, settings) {
    // Hide if effectively zero (charging/discharging calculation pending)
    if (power <= 0.01 && power >= -0.01) {
        return '';
    }

    if (settings && settings.get_boolean('showdecimals')) {
        return Math.abs(power).toFixed(2);
    }

    // Default behavior: Round to integer
    return Math.round(Math.abs(power)).toString();
}

function formatTimeRemaining(seconds) {
    if (seconds <= 0) return null;

    let time = Math.round(seconds / 60);
    if (time <= 0) return null;

    let minutes = time % 60;
    let hours = Math.floor(time / 60);
    return _('%d\u2236%02d').format(hours, minutes);
}

const _powerToggleSyncOverride = function (settings) {
    return function () {
        // Safety check: prevent infinite loops
        const now = Date.now();
        if (now - lastOverrideTime < 1000) {
            overrideCallCount++;
            if (overrideCallCount > MAX_CALLS_PER_SECOND) {
                logDebug(`SAFETY: Too many calls per second (${overrideCallCount}). Stopping override.`);
                return false;
            }
        } else {
            overrideCallCount = 0;
        }
        lastOverrideTime = now;

        // Only set title, don't touch visibility - that's handled separately
        if (!this._proxy.IsPresent) {
            return false;
        }

        batteryCorrection = getAutopath();
        const percentage = Math.round(this._proxy.Percentage) + '%';
        let state = this._proxy.State;
        const status = getStatus(batteryCorrection);

        // Build display string
        let displayParts = [];

        // Add percentage if enabled and circular indicator is off
        const showPercentage = settings.get_boolean('percentage');
        const showPercentageOutside = settings.get_boolean('showpercentageoutside') && showPercentage;
        const showPercentageText = showPercentageOutside;
        if (showPercentageText) {
            displayParts.push(percentage);
        }

        // Add time remaining if enabled
        const showTimeRemaining = settings.get_boolean('timeremaining');
        if (showTimeRemaining) {
            let seconds = 0;
            if (state === UPower.DeviceState.CHARGING) {
                seconds = this._proxy.TimeToFull;
            } else if (state === UPower.DeviceState.DISCHARGING) {
                seconds = this._proxy.TimeToEmpty;
            }

            let timeStr = formatTimeRemaining(seconds);
            if (timeStr) {
                displayParts.push(timeStr);
            }
        }

        // Add watts if enabled
        const showWatts = settings.get_boolean('showwatts');
        if (showWatts) {
            const power = getPower(batteryCorrection);
            let wattStr = '';
            const formattedPower = formatWatts(power, settings);

            if (formattedPower !== '') {
                if (status.includes('Charging')) {
                    wattStr = '+' + formattedPower + 'W';
                } else if (status.includes('Discharging')) {
                    wattStr = '-' + formattedPower + 'W';
                } else if (status.includes('Unknown')) {
                    wattStr = '?';
                } else {
                    if (state === UPower.DeviceState.FULLY_CHARGED) {
                        wattStr = 'âˆž';
                    }
                }
            }

            if (wattStr) {
                displayParts.push(wattStr);
            }
        }

        updateCircleIndicatorStatus(this._proxy, settings);


        // Handle fully charged without custom display
        if (state === UPower.DeviceState.FULLY_CHARGED && displayParts.length === 0) {
            if (showPercentageOutside && showPercentage) {
                this.title = percentage;
                return true;
            }
            return false;
        }

        // If nothing to display, check if percentage is enabled
        if (displayParts.length === 0) {
            if (showPercentageText) {
                this.title = percentage;
                return true;
            } else {
                return false;
            }
        } else {
            const title = displayParts.join(' ');
            this.title = circleIndicatorEnabled(settings) ? ` ${title}` : title;
            return true;
        }
    };
};

export default class BatConsumptionWattmeter extends Extension {
    enable() {
        const buildDate = new Date().toISOString();
        this._im = new InjectionManager();

        // Set update callback for async reads
        updateUI = () => this._syncToggle();

        this._settings = this.getSettings();
        const settings = this._settings;
        const updateLogSettings = () => {
            DEBUG = settings.get_boolean('debug');
            if (!DEBUG) {
                currentLogLevel = LogLevel.WARN;
                currentLogFilePath = null;
                logFileInitialized = false;
                logToFileEnabled = false;
                return;
            }

            const selected = settings.get_int('loglevel');
            const normalized = Math.max(LogLevel.VERBOSE, Math.min(LogLevel.ERROR, selected));
            currentLogLevel = normalized;
            logToFileEnabled = settings.get_boolean('logtofile');
            if (logToFileEnabled) {
                currentLogFilePath = resolveLogFilePath(settings);
                initLogFile(currentLogFilePath);
            } else {
                currentLogFilePath = null;
                logFileInitialized = false;
            }
        };


        logDebug('\n[Battery Power Monitor] ===== EXTENSION ENABLED =====');
        logDebug(`[Battery Power Monitor] Build date: ${buildDate}`);

        updateLogSettings();
        this._debugConnection = this._settings.connect('changed::debug', updateLogSettings);
        this._logLevelConnection = this._settings.connect('changed::loglevel', updateLogSettings);
        this._logPathConnection = this._settings.connect('changed::logfilepath', updateLogSettings);
        this._logToFileConnection = this._settings.connect('changed::logtofile', updateLogSettings);

        ensureCircleIndicator(settings, this.path);
        ensureBatteryIndicator(settings, this.path);

        // Override _sync to set custom title and control visibility
        this._im.overrideMethod(Indicator.prototype, '_sync', function (_sync) {
            return function () {
                _sync.call(this);

                const powerToggle = this._systemItem?.powerToggle;
                if (!powerToggle || !settings) {
                    return;
                }
                const overrideFunc = _powerToggleSyncOverride(settings);
                const hasOverride = overrideFunc.call(powerToggle);

                const showLabelText = (settings.get_boolean('showpercentageoutside') && settings.get_boolean('percentage'))
                    || settings.get_boolean('timeremaining')
                    || settings.get_boolean('showwatts');
                const showIcon = settings.get_boolean('showicon');
                const showCircle = circleIndicatorEnabled(settings);
                const showStockIcon = showIcon && !showCircle && !batteryIndicator;
                const percentageValue = this._proxy?.Percentage ?? powerToggle?._proxy?.Percentage;
                const labelStyle = getLabelStyleFromPercentage(
                    percentageValue,
                    settings.get_boolean('showcolored')
                );
                if (this._icon) {
                    this._icon.visible = showStockIcon;
                    if (showStockIcon) {
                        this._icon.icon_name = 'battery-good-symbolic';
                    }
                }
                if (powerToggle?.set_style) {
                    powerToggle.set_style(labelStyle);
                }
                powerToggle?._title?.set_style?.(labelStyle);
                powerToggle?._titleLabel?.set_style?.(labelStyle);
                this.visible = hasOverride && shouldShowIndicator;
                if (this._percentageLabel) {
                    this._percentageLabel.visible = showLabelText && hasOverride && shouldShowIndicator;
                    this._percentageLabel.set_style(labelStyle);
                }
            };
        });

        // Listen for battery changes and update visibility
        // Listen for battery changes and update visibility
        this._batteryWatching = null;
        this._refreshTimeoutId = null;
        this._settingsConnections = [];
        const settingKeys = [
            'showicon', 'batterysize', 'batteryheight', 'circlesize',
            'percentage', 'showpercentageoutside', 'timeremaining',
            'showwatts', 'showdecimals', 'hidecharging', 'hidefull', 'hideidle',
            'usecircleindicator', 'showcolored', 'forcebolt',
            'interval', 'debug', 'loglevel', 'logtofile', 'logfilepath'
        ];

        // Initial sync of globals
        updateGlobalsFromSettings(this._settings);
        this._updateInterval(this._settings);

        settingKeys.forEach(key => {
            const connection = this._settings.connect(`changed::${key}`, () => {
                logDebug(`Setting changed: ${key}`);

                // Update globals if debug settings changed
                if (['debug', 'loglevel', 'logtofile', 'logfilepath'].includes(key)) {
                    updateGlobalsFromSettings(this._settings);
                }

                // Update interval if interval changed
                if (key === 'interval') {
                    this._updateInterval(this._settings);
                }

                ensureCircleIndicator(this._settings, this.path);
                ensureBatteryIndicator(this._settings, this.path);
                this._updateBatteryVisibility(this._settings);
                this._getBattery((proxy) => {
                    updateCircleIndicatorStatus(proxy, this._settings);
                    updateBatteryIndicatorStatus(proxy, this._settings);
                });
                this._syncToggle();
            });
            this._settingsConnections.push(connection);
        });


        // Watch battery for property changes
        this._getBattery((proxy) => {
            this._batteryWatching = proxy.connect('g-properties-changed', () => {
                {
                    try {
                        console.log(`[BatConsumptionWattmeter] Event: g-properties-changed. Rate=${proxy.EnergyRate}, State=${proxy.State}`);
                    } catch (e) {
                        console.log(`[BatConsumptionWattmeter] Event: g-properties-changed (Error reading proxy: ${e.message})`);
                    }
                }
                this._updateBatteryVisibility(this._settings);
                updateCircleIndicatorStatus(proxy, this._settings);
                updateBatteryIndicatorStatus(proxy, this._settings);
                this._syncToggle();

            });
        });

        this._updateBatteryVisibility(this._settings);
        this._getBattery((proxy) => {
            updateBatteryIndicatorStatus(proxy, this._settings);
        });
        this._syncToggle();

    }

    _getBattery(callback) {
        let system = panel.statusArea.quickSettings._system;
        if (system && system._systemItem._powerToggle) {
            callback(system._systemItem._powerToggle._proxy, system);
        }
    }

    _updateBatteryVisibility(settings) {
        this._getBattery((proxy, powerToggle) => {
            const showIcon = settings.get_boolean('showicon');
            const showPercentage = settings.get_boolean('percentage');
            const showPercentageOutside = settings.get_boolean('showpercentageoutside') && showPercentage;
            const showTimeRemaining = settings.get_boolean('timeremaining');
            const showWatts = settings.get_boolean('showwatts');
            const showCircle = settings.get_boolean('usecircleindicator');
            const showLabelText = showPercentageOutside || showTimeRemaining || showWatts;
            const effectiveCircle = showCircle && showIcon;
            const effectiveIcon = showIcon && !showCircle;
            let shouldShow = true;

            // Hide if nothing would be visible
            if (!showLabelText && !effectiveCircle && !effectiveIcon) {
                logDebug('Hiding battery - no visible options');
                shouldShow = false;
            }

            // Check hide when charging
            const hideCharging = settings.get_boolean('hidecharging');
            const status = getStatus(getAutopath());
            if (hideCharging && status.includes('Charging')) {
                logDebug('Hiding battery - charging');
                shouldShow = false;
            }

            // Check hide when full
            const hideFull = settings.get_boolean('hidefull');
            if (hideFull && proxy.State === UPower.DeviceState.FULLY_CHARGED) {
                logDebug('Hiding battery - full');
                shouldShow = false;
            }

            // Check hide when idle
            const hideIdle = settings.get_boolean('hideidle');
            const isIdle = proxy.State !== UPower.DeviceState.CHARGING && proxy.State !== UPower.DeviceState.DISCHARGING;
            if (hideIdle && isIdle) {
                logDebug('Hiding battery - idle');
                shouldShow = false;
            }

            shouldShowIndicator = shouldShow;
            if (shouldShow) {
                logDebug('Showing battery');
                powerToggle.show();
            } else {
                powerToggle.hide();
            }

            if (circleIndicator) {
                circleIndicator.visible = shouldShow && effectiveCircle;
            }
            if (batteryIndicator) {
                batteryIndicator.visible = shouldShow && effectiveIcon;
            }
        });
    }

    _updateInterval(settings) {
        if (this._refreshTimeoutId) {
            GLib.source_remove(this._refreshTimeoutId);
            this._refreshTimeoutId = null;
        }

        const interval = settings.get_int('interval');
        if (interval > 0) {
            logDebug(`Setting refresh interval to ${interval} seconds`);
            this._refreshTimeoutId = GLib.timeout_add_seconds(GLib.PRIORITY_DEFAULT, interval, () => {
                this._syncToggle();
                return GLib.SOURCE_CONTINUE;
            });
        }
    }

    disable() {
        // Clear interval
        if (this._refreshTimeoutId) {
            GLib.source_remove(this._refreshTimeoutId);
            this._refreshTimeoutId = null;
        }

        // Disconnect battery watching
        if (this._batteryWatching !== null) {
            this._getBattery((proxy) => {
                proxy.disconnect(this._batteryWatching);
            });
            this._batteryWatching = null;
        }

        // Disconnect settings listeners
        if (this._settingsConnections && this._settings) {
            this._settingsConnections.forEach(connection => {
                this._settings.disconnect(connection);
            });
            this._settingsConnections = [];
        }
        if (this._debugConnection && this._settings) {
            this._settings.disconnect(this._debugConnection);
            this._debugConnection = null;
        }
        if (this._logLevelConnection && this._settings) {
            this._settings.disconnect(this._logLevelConnection);
            this._logLevelConnection = null;
        }
        if (this._logPathConnection && this._settings) {
            this._settings.disconnect(this._logPathConnection);
            this._logPathConnection = null;
        }
        if (this._logToFileConnection && this._settings) {
            this._settings.disconnect(this._logToFileConnection);
            this._logToFileConnection = null;
        }


        updateUI = null;
        this._im.clear();
        this._im = null;
        destroyCircleIndicator();
        destroyBatteryIndicator();
        resetPowerToggleStyles();
        this._syncToggle();

        // Null out references
        this._batteryWatching = null;
        this._settingsConnections = null;
        this._settings = null;
        batteryCorrection = null;

        lastOverrideTime = 0;
        overrideCallCount = 0;
        fileCache.clear();
        pendingReads.clear();
    }

    _syncToggle() {
        const system = panel.statusArea.quickSettings?._system;
        if (system?._sync) {
            system._sync();
            return;
        }
        system?._systemItem?.powerToggle?._sync();
    }
}
const CIRCLE_MIN_SIZE_USER = 12;
